// Copyright 2022-2023 Fleek Network
// SPDX-License-Identifier: Apache-2.0, MIT
use async_trait::async_trait;
use narwhal_executor::ExecutionState;
use narwhal_types::{Batch, ConsensusOutput};
use std::sync::Arc;
use tokio::sync::Notify;
use tracing::error;
use ursa_application::interface::application::{
    ApplicationUpdate, ExecutionData, Transaction, TransactionResponse,
};

pub struct Execution {
    /// Managing certificates generated by narwhal.
    pub transactions: ApplicationUpdate,
    pub reconfigure_notify: Arc<Notify>,
}

impl Execution {
    pub fn new(transactions: ApplicationUpdate, reconfigure_notify: Arc<Notify>) -> Self {
        Self {
            transactions,
            reconfigure_notify,
        }
    }

    async fn submit_batch(&self, batch: Vec<Batch>) {
        let mut change_epoch = false;
        for batch in batch {
            for txn in batch.transactions {
                if let TransactionResponse::Success(ExecutionData::EpochChange) =
                    self.deliver_tx(txn).await
                {
                    change_epoch = true;
                }
            }
        }
        if change_epoch {
            self.reconfigure_notify.notify_waiters();
        }
    }
    async fn deliver_tx(&self, txn: Vec<u8>) -> TransactionResponse {
        let txn: Transaction = bincode::deserialize(&txn).unwrap();

        self.transactions.run(txn).await.unwrap()
    }
}

#[async_trait]
impl ExecutionState for Execution {
    async fn handle_consensus_output(&self, consensus_output: ConsensusOutput) {
        for (_, batches) in consensus_output.batches {
            self.submit_batch(batches).await
        }
    }

    async fn last_executed_sub_dag_index(&self) -> u64 {
        0
    }
}
