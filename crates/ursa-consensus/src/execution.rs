// Copyright 2022-2023 Fleek Network
// SPDX-License-Identifier: Apache-2.0, MIT

use async_trait::async_trait;
use bytes::Bytes;
use narwhal_executor::ExecutionState;
use narwhal_types::ConsensusOutput;
use tokio::sync::mpsc::Sender;
use tracing::error;

type Epoch = u64;

pub struct Execution<N> {
    /// a store for epoch
    _store: N,
    /// current epoch store implementation
    epoch: Epoch,
    /// managing certificates generated by narwhal
    transactions: Sender<Vec<u8>>,
}

impl<N> Execution<N> {
    pub fn new(store: N, epoch: Epoch, transactions: Sender<Vec<u8>>) -> Self {
        Self {
            _store: store,
            epoch,
            transactions,
        }
    }
}

#[async_trait]
impl<N: Send + Sync> ExecutionState for Execution<N> {
    async fn handle_consensus_output(&self, consensus_output: ConsensusOutput) {
        for (_, batches) in consensus_output.batches {
            for batch in batches {
                for transaction in batch.transactions.into_iter() {
                    assert_eq!(transaction, Bytes::from(self.epoch.to_be_bytes().to_vec()));
                    if let Err(err) = self.transactions.send(transaction).await {
                        error!("Failed to send txn: {}", err);
                    }
                }
            }
        }
    }

    async fn last_executed_sub_dag_index(&self) -> u64 {
        0
    }
}
